[상속]
- 부모의 코드(필드/메서드)를
  자식이 자신의 것 처럼 사용하는 기술

[특징/장점]
1. 재사용성 증가
  (한 번 작성한 부모 코드를 자식들이 재사용 가능!)

2. 유지 보수성 증가
  (부모 코드만 수정하면 자식은 그대로 있어도됨)

3. 공통적인 규약 정의
  (물려 받은 자식들의 형태가 부모와 비슷함)
  -> 부모 코드 수정, 추가, 제거 시
      자식도 일괄 변경

[상속 키워드] : extends (확장하다)
-> 부모의 필드/메서드를 상속 받은 자식의 크기가 커지기 때문에
    "확장하다" 키워드 사용
[상속 주의 사항]
1) 부모의 생성자는 상속 X

2) 부모의 private 필드/메서드는
   상속 받은 자식도 직접 접근 불가능

[상속 메모리 구조]
- 자식 객체 생성 시
  부모 객체가 같이 생성되어
   자식 객체 내부에 배치됨

[super() 생성자]
- 자식 클래스에서 상위(부모) 클래스 생성자를 호출하는 구문

- 자식 생성자의 첫번째 구문에만 적어야됨 적지 않으면 컴파일러가 자동생성함

[오버라이딩(Overriding, 덮어쓰기/재정의)]
- 상송 관계에서 부모의 메서드를
  자식이 용도에 맞게 재정의 하는 것
  
[오버로딩(Overloading, 과적)]
- 하나의 클래스에 같은 이름의 메서드를 여러 개 작성하는 기술
- 비슷한 기능을 제공하는 메서드들을 하나의 이름으로 관리

* 오버로딩 vs 오버라이딩

(차이점) 왼 오버로딩 오른쪽 오버라이딩
같은 클래스에 작성 / 하위(자식) 클래스에 작성
매개변수(개수,순서,타입) 하나라도 다름 / 매개변수 동일
반환형 관계 없음 / 반환형 동일(같아야됨)
접근 제어자 관계 없음 / 접근 제어가 같거나 넓은 범위
예외처리 관계 없음 / 예외처리 같거나 좁은 범위

(공통점) : 메서드 이름이 동일해야 한다


면접에서 주로 물어보는것
1.클래스와 인스턴스의 차이


2.오버로딩과 오버라이딩의 차이


3.추상 클래스와 인터페이스의 차이


[ final 예약어 ]

- final class : 상속 불가 클래스

- final method : 오버라이딩 불가 메서드

- final variable : 값 대입 불가 변수(상수)

* 자바에서 클래스간의 상속은 단일 상속만 지원!!


* 객체 지향 프로그래밍
- 현실은 객체와 객체의 상호 작용으로
  사건이 발생한다는 개념을 컴퓨터로 옮겨놓은 것

- 객체는 속성/기능으로 이루어짐

class : 객체의 속성과 기능을 정의한 것(문서)

instance : class에 작성된 내용을 토대로
 	메모리에 생성된 객체

[다형성, Polymorphism]
- 다양한 형태를 지니는 성질

[객체에 대한 다형성]
1. 업 캐스팅
- 자식 객체가 부모 객체로 변하는 것
   (자식 내 부모 부분만 참조 하는것)

- 참조 변수의 타입      :부모 타입
- 참조하는 객체의 타입 : 자식 타입

- 매개 변수의 다형성
- 반환형의     다형성
- 객체 배열의 다형성

- 동적 바인딩


2. 다운 캐스팅
- 업 캐스팅 되어있는 객체의 참조 변수를
  자식 타입으로 강제 형변환
  (자식 객체를 참조 할 수 있게됨)

ex)
Parent p = new Child();
Child c = (Child)p; //다운 캐스팅

[instanceof 연산자]
- 참조 변수 instanceof 클래스명

- "참조변수" 가 참조하는 객체가
  "클래스명" 클래스로 만들어진 객체
  또는 상속 받은 객체인 경우 true 반환
  아니면 false 반환


[바인딩(Binding)]
- 메서드 호출부와 실제 메서드를 연결하는 것

1. 정적 바인딩
- 프로그램 실행 "전"
  컴파일 단계에서 메서드 - 메서드 호출부 연결

- 참조변수의 자료형을 확인하여
  해당 클래스의 메서드와 연결

2.동적 바인딩
- 프로그램 실행 "중" (runtime 시)
  메서드 호출부와
  실재 참조하는 객체의 오버라이딩된 메서드와 연결
  (오버라이딩된 메서드가 우선권을 갖는다)


추상 클래스 : 고통된 클래스의 묶음
인터페이스  : 관련 없는 클래스 접점



* Java Collection Framework
  - 자바의 자료구조 모음

* 컬렉션의 특징
  - 크기 제한 X
  - 추가,수정,삭제,정렬 등의 기능 제공
  - 모든 객체 저장가능
    단, 제네릭스를 이용해서 타입 제한

* 컬렉션 제공 인터페이스
- List   : 인덱스를 이용해서 순서 유지,중복 허용
- Set   : 순서 유지X,중복 허용
- Map : K,V 쌍으로 데이터 관리

* List, Set은 고통된 이름의 메서드가 많아서
  이를 추상화 하여 Collection 인터페이스를 만들어 상속

SOLID
1. 단일 책임 원칙 (Single Responsibility Priniple, SRP)
-> 하나의 객체는 하나의 책임(역할)만 갖는다

2. 개방-폐쇄 원칙 (Open/Closed Principle, OCP)
-> 확장엔 개방, 수정엔 폐쇄
  -> 기존 코드 수정 X, 새코드를 작성
  -> 원래 잘 동작하던 코드를 유지할려고

3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
- 서브 타입은 언제나 교체할 수 있도록 해야한다
  -> 자식 객체가 부모 객체(또는 부모 객체 상속)로
      교환 되어도 기존 코드에 문제가 없어야 한다

4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
- 인터페이스를 최대한 필요한 기능만 갖도록 작게 만들자
  -> 자식이 불필요한 메서드를 상송하지 않도록 하기 위해서

5. 의존 역전 원칙 (Dependency Inversion Principle, DIP)
- 결합도를 낮추고, 응집도를 높여서
  유지보수의 유연성 확보(추상화)

null - 참조하는 값이 없다


null       : 참조하는 객체가 없다
비어있다 : 참조하는 객체는 있는데 저장된 데이터가 없다
""(빈칸)   : 작성된 내용이 없는 문자열

undefined : 정의되지 않음

list <String> list1 = null;
if (list1.isEmpty()){ // 올바른 코드인가?  0 / X  정답 : 올바른 코드가 아니다
}
-> 참조하는 객체가 없음
 -> NullPointerException 발생

----------------------------------------------------------------------------------------

List<String> list2 = new Arratlist<String>();

if (list2 == null){}    // 실행 x
if (list2.isEmpty()){} // 실행 o


	/* File 클래스
	 * 
	 * - java.io 패키지
 * 
 * - 파일/디렉토리(폴더)를 관리하는 클래스
 *   (파일/디렉토리 존재 유무 관계 없음)
 *   
 * - 파일 생성, 제거, 이름, 크기, 마지막 수정일, 존재여부 등의 기능 제공 
 *   
 * - File 클래스 메서드
 * 
 * boolean  mkdir()          : 디렉토리 생성
 * boolean  mkdirs()         : 경로상의 모든 디렉토리 생성
 * boolean  createNewFile()  : 파일 생성
 * boolean  delete()         : 파일/디렉토리 삭제
 * String   getName()        : 파일 이름 반환
 * String   parent()         : 파일이 저장된 디렉토리 반환
 * String   getPath()        : 전체 경로 반환
 * boolean  isFile()         : 현재 File 객체가 관리하는게 파일이면 true
 * boolean  isDirectory()    : 현재 File 객체가 관리하는게 디렉토리 true
 * boolean  exists()         : 파일/디렉토리가 존재하면 true, 아님 false
 * long     length()         : 파일 크기 반환
 * long     lastModified()   : 파일 마지막 수정일 (1970.01.01 09:00 부터 현재까지 지난 시간을 ms 단위로 반환)
 * String[] list()           : 디렉토리 내 파일 목록을 String[] 배열로 반환
 * File[]   listFiles()      : 디렉토리 내 파일 목록을 File[] 배열로 반환 
*/


- 오버라이딩 시 throws 구문 작성 방법
1) 같거나 좁은 범위(세세한, 구체적인 예외)
2) throws 제거 가능(예외 발생 안하는 코드로 재정의)

- 사용자 정의 예외
  사용자가 필요한 예외 클래스 만들 수 있음

- 사용자 정의 예외 생성 방법
  -> 아무 Exception 클래스 상속
  1) Checked Exception    - RuntimeException 뺀 나머지 상속
  2) UnChecked Exception - RuntimeException 또는 자식 상속

---------------------------- IO 정리 ----------------------------------------

IO(입출력)
- 입력 : 프로그램이 데이터를 읽음(read)
- 출력 : 프로그램이 데이터를 씀(write)

File 클래스
- 파일 존재 여부 관계 없이
  파일을 참조하고 관리하는 객체
경로 작성 시 /,\(백슬레시) 차이
- Linux/Mac :  /
- windows   :  \

절대경로 : root(/, C:, D:) 최상위 폴더를 기준으로
		       원하는 위치까지의 경로를 작성하는 것
상대경로 : 현재 위치(Java는 현재 프로젝트)를 기준으로
	 원하는 위치까지의 경로를 작성하는 것

스트림
- 뜻 : 흐름, 개울, 시내
- 실질적 의미 : 데이터가 한 방향으로 흐르게하는 객체

InputStream / OutputStream
- 바이트 기반 스트림(1byte씩 입출력)

- 기반 스트림 : 단독으로 생성되어 사용 가능한 스트림
- 보조 스트림 : 단독 생성 불가 기반 스트림에 붙어 기능 향상이나 추가 기능을 제공함

Buffer(버퍼) : 데이터를 모아놓는 메모리 공간
	     ex) 장바구니, 트럭
	       -> 한 번에 많은 데이터를 묶어서 전달
	       -> Buffer를 이용한 속도가 향상된다!

static : 정적 메모리 영역
- 프로그램 실행 시 static이 붙은 변수/메서드를
  static 메모리 영역에 할당
  (클래스명.변수 / 클래스명.메서드명 형태로 할당)

- 프로그램 "종료" 될 떄 까지 유지

- 인스턴스 생성 없이 사용 가능

- 프로그램 내에서 공유

[내부 클래스]

1. 인스턴스 내부 클래스
 - 외부 클래스의 멤버 처럼 활용되는 내부 클래스
 - 외부 클래스의 인스턴스(닭)가 존재 해야지만 
   내부 클래스 인스턴스(달걀) 생성 가능

2. 정적(static) 내부 클래스
 -  외부 인스턴스 생성 없이
    내주 인스턴스 생성 가능!
    (new 외부 클래스명.내부클래스명())

3. 지역 내부 클래스
 - 외부 클래스의 멤버 메서드 내에 존재하는 내부 클래스
 - 외부 메서드의 내부에서만 생성, 사용 가능함!

4.익명 내부 클래스
 - 이름이 없는 내부 클래스
 - 인터페이스, 추상클래스를 상속 받은 구현체를
   따로 만들지 않고

   필요한 곳에서 클래스를 정의(추상 메서드 오버라이딩)하는
   형식의 클래스
 - 1회용으로 주로 사용

[ 함수형 인터페이스 ]
 - 추상 메서드가 1개만 있는 메서드
 
 @FunctionalInterface 어노테이션
 - 함수형 인터페이스 작성법이 맞는지
   컴파일러에게 검증하라고 지시하는 어노테이션


 람다식(또는 람다 표현식)
 - 메서드를 하나의 식으로 표현하는 익명 함수
 - 함수형 인터페이스를 구현하는데 사용

 Java 제공 함수형 인터페이스
 - java.util.function 패키지에 존재

1. Consumer<T>  : 매개 변수를 소비,   매개별수 O, 반환형 X
2. Supplier<T>    : 값만 제공,            매개별수 X, 반환형 O
3. Function<T,R> :  T를 받고 R을 반환, 매개변수 O, 반환형 O
4. Opertor<T>    :  T를 받고 T반환 ,    매개변수 O, 반환형 O
5. Predicate<T>   : T를 받고 T/F 반환 , 매개변수 O, 반환형 O

메서드 참조
- 함수형 인터페이스를 람다식으로 표현하는 것이 아닌
  이미 존재하는 메서드를 참조시키는 방법

ex) Consumer<T> con = () -> {}; (X)
    Consumer<T> con = 클래스명::메서드명 (O) 